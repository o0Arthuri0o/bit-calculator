# Тестовые примеры для проверки операций битового калькулятора

## Логические операции

### AND (побитовое И)
**Описание:** Результат 1 только если оба бита равны 1

#### Пример 1: Базовый случай
- **Вход:** r0 = 5 (0b0101), r1 = 7 (0b0111)
- **Ожидаемый результат:** 5 (0b0101)
- **Объяснение:** AND возвращает 1 только там, где оба операнда имеют 1. 5 & 7 = 0b0101 & 0b0111 = 0b0101 = 5

#### Пример 2: Очистка битов
- **Вход:** r0 = 255 (0b11111111), r1 = 240 (0b11110000)
- **Ожидаемый результат:** 240 (0b11110000)
- **Объяснение:** Маска 240 очищает младшие 4 бита, оставляя только старшие 4 бита

#### Пример 3: Нулевой результат
- **Вход:** r0 = 170 (0b10101010), r1 = 85 (0b01010101)
- **Ожидаемый результат:** 0 (0b00000000)
- **Объяснение:** Операция AND между взаимно инвертированными битами всегда дает 0

#### Пример 4: С отрицательными числами
- **Вход:** r0 = -1 (0xFFFFFFFF), r1 = 15 (0b00001111)
- **Ожидаемый результат:** 15 (0b00001111)
- **Объяснение:** -1 в 32-битном представлении это все единицы, AND с любым числом возвращает само число

---

### ORR (побитовое ИЛИ)
**Описание:** Результат 1 если хотя бы один бит равен 1

#### Пример 1: Базовый случай
- **Вход:** r0 = 5 (0b0101), r1 = 7 (0b0111)
- **Ожидаемый результат:** 7 (0b0111)
- **Объяснение:** OR возвращает 1 если хотя бы один операнд имеет 1. 5 | 7 = 0b0101 | 0b0111 = 0b0111 = 7

#### Пример 2: Установка битов
- **Вход:** r0 = 170 (0b10101010), r1 = 85 (0b01010101)
- **Ожидаемый результат:** 255 (0b11111111)
- **Объяснение:** OR между взаимно инвертированными битами устанавливает все биты в 1

#### Пример 3: С нулем
- **Вход:** r0 = 42 (0b00101010), r1 = 0
- **Ожидаемый результат:** 42 (0b00101010)
- **Объяснение:** OR с нулем не изменяет значение операнда

#### Пример 4: С отрицательными числами
- **Вход:** r0 = 10 (0b00001010), r1 = -1 (0xFFFFFFFF)
- **Ожидаемый результат:** -1 (0xFFFFFFFF)
- **Объяснение:** OR с -1 (все единицы) всегда дает -1

---

### EOR (исключающее ИЛИ, XOR)
**Описание:** Результат 1 если биты различны

#### Пример 1: Базовый случай
- **Вход:** r0 = 5 (0b0101), r1 = 7 (0b0111)
- **Ожидаемый результат:** 2 (0b0010)
- **Объяснение:** XOR возвращает 1 только там, где биты различны. 5 ^ 7 = 0b0101 ^ 0b0111 = 0b0010 = 2

#### Пример 2: Инверсия через XOR
- **Вход:** r0 = 42 (0b00101010), r1 = 255 (0b11111111)
- **Ожидаемый результат:** 213 (0b11010101)
- **Объяснение:** XOR с маской из всех единиц инвертирует все биты

#### Пример 3: Обмен значениями
- **Вход:** r0 = 10, r1 = 20
- **Ожидаемый результат:** 30
- **Объяснение:** 10 ^ 20 = 30. XOR используется в алгоритмах обмена без временной переменной

#### Пример 4: С одинаковыми значениями
- **Вход:** r0 = 15 (0b1111), r1 = 15 (0b1111)
- **Ожидаемый результат:** 0
- **Объяснение:** XOR одинаковых значений всегда дает 0

---

### BIC (Bit Clear, очистка битов)
**Описание:** A AND NOT B - очищает биты в A, которые установлены в B

#### Пример 1: Базовый случай
- **Вход:** r0 = 255 (0b11111111), r1 = 15 (0b00001111)
- **Ожидаемый результат:** 240 (0b11110000)
- **Объяснение:** BIC очищает младшие 4 бита, оставляя старшие 4 бита установленными

#### Пример 2: Очистка конкретных битов
- **Вход:** r0 = 170 (0b10101010), r1 = 85 (0b01010101)
- **Ожидаемый результат:** 170 (0b10101010)
- **Объяснение:** BIC очищает только те биты в r0, которые установлены в r1. Здесь биты не пересекаются, поэтому результат равен r0

#### Пример 3: Очистка всех битов
- **Вход:** r0 = 255 (0b11111111), r1 = 255 (0b11111111)
- **Ожидаемый результат:** 0
- **Объяснение:** BIC с маской из всех единиц очищает все биты

#### Пример 4: С отрицательными числами
- **Вход:** r0 = -1 (0xFFFFFFFF), r1 = 15 (0b00001111)
- **Ожидаемый результат:** -16 (0xFFFFFFF0)
- **Объяснение:** BIC очищает младшие 4 бита, оставляя остальные установленными

---

### MVN (Move Not, инверсия)
**Описание:** NOT A - инвертирует все биты (унарная операция)

#### Пример 1: Базовый случай
- **Вход:** r0 = 5 (0b0101), r1 = любое (игнорируется)
- **Ожидаемый результат:** -6 (0xFFFFFFFA)
- **Объяснение:** MVN инвертирует все биты: ~5 = ~0b0101 = 0b1111...1010 = -6 в знаковом представлении

#### Пример 2: Инверсия нуля
- **Вход:** r0 = 0, r1 = любое (игнорируется)
- **Ожидаемый результат:** -1 (0xFFFFFFFF)
- **Объяснение:** Инверсия нуля дает все единицы, что в знаковом представлении равно -1

#### Пример 3: Инверсия -1
- **Вход:** r0 = -1 (0xFFFFFFFF), r1 = любое (игнорируется)
- **Ожидаемый результат:** 0
- **Объяснение:** Инверсия всех единиц дает все нули

#### Пример 4: Инверсия положительного числа
- **Вход:** r0 = 42 (0b00101010), r1 = любое (игнорируется)
- **Ожидаемый результат:** -43 (0xFFFFFFD5)
- **Объяснение:** Инверсия положительного числа дает отрицательное число в дополнительном коде

---

## Операции сдвига

### LSL (Logical Shift Left, логический сдвиг влево)
**Описание:** Сдвиг влево, справа входят нули. Эквивалентно умножению на 2^n

#### Пример 1: Сдвиг на 1 бит
- **Вход:** r0 = 5 (0b0101), shift = 1
- **Ожидаемый результат:** 10 (0b1010), C = 0
- **Объяснение:** LSL на 1 бит умножает на 2. 5 << 1 = 10. Флаг C = старший выдвинутый бит

#### Пример 2: Сдвиг на 2 бита
- **Вход:** r0 = 3 (0b0011), shift = 2
- **Ожидаемый результат:** 12 (0b1100), C = 0
- **Объяснение:** LSL на 2 бита умножает на 4. 3 << 2 = 12

#### Пример 3: Сдвиг с переносом
- **Вход:** r0 = 0x80000000 (2147483648), shift = 1
- **Ожидаемый результат:** 0 (0x00000000), C = 1
- **Объяснение:** Сдвиг числа с установленным старшим битом выдвигает 1 в флаг C, результат обнуляется

#### Пример 4: Сдвиг на 0
- **Вход:** r0 = 42, shift = 0
- **Ожидаемый результат:** 42, C = текущий C
- **Объяснение:** Сдвиг на 0 не изменяет значение, флаг C сохраняется

---

### LSR (Logical Shift Right, логический сдвиг вправо)
**Описание:** Сдвиг вправо, слева входят нули. Эквивалентно беззнаковому делению на 2^n

#### Пример 1: Сдвиг на 1 бит
- **Вход:** r0 = 10 (0b1010), shift = 1
- **Ожидаемый результат:** 5 (0b0101), C = 0
- **Объяснение:** LSR на 1 бит делит на 2. 10 >>> 1 = 5. Флаг C = младший выдвинутый бит

#### Пример 2: Сдвиг на 2 бита
- **Вход:** r0 = 12 (0b1100), shift = 2
- **Ожидаемый результат:** 3 (0b0011), C = 0
- **Объяснение:** LSR на 2 бита делит на 4. 12 >>> 2 = 3

#### Пример 3: Сдвиг с переносом
- **Вход:** r0 = 1 (0b0001), shift = 1
- **Ожидаемый результат:** 0 (0b0000), C = 1
- **Объяснение:** Сдвиг числа 1 выдвигает 1 в флаг C, результат становится 0

#### Пример 4: Сдвиг отрицательного числа
- **Вход:** r0 = -1 (0xFFFFFFFF), shift = 1
- **Ожидаемый результат:** 2147483647 (0x7FFFFFFF), C = 1
- **Объяснение:** LSR обрабатывает число как беззнаковое, поэтому -1 становится большим положительным числом

---

### ASR (Arithmetic Shift Right, арифметический сдвиг вправо)
**Описание:** Сдвиг вправо с сохранением знака. Слева копируется бит знака

#### Пример 1: Сдвиг положительного числа
- **Вход:** r0 = 10 (0b1010), shift = 1
- **Ожидаемый результат:** 5 (0b0101), C = 0
- **Объяснение:** ASR положительного числа работает как LSR. 10 >> 1 = 5

#### Пример 2: Сдвиг отрицательного числа
- **Вход:** r0 = -10 (0xFFFFFFF6), shift = 1
- **Ожидаемый результат:** -5 (0xFFFFFFFB), C = 0
- **Объяснение:** ASR сохраняет знак, поэтому -10 >> 1 = -5. Старший бит (знак) копируется

#### Пример 3: Сдвиг на 2 бита отрицательного числа
- **Вход:** r0 = -8 (0xFFFFFFF8), shift = 2
- **Ожидаемый результат:** -2 (0xFFFFFFFE), C = 0
- **Объяснение:** ASR делит с сохранением знака. -8 >> 2 = -2

#### Пример 4: Сдвиг с переносом
- **Вход:** r0 = -1 (0xFFFFFFFF), shift = 1
- **Ожидаемый результат:** -1 (0xFFFFFFFF), C = 1
- **Объяснение:** ASR -1 сохраняет все единицы, так как бит знака копируется

---

### ROR (Rotate Right, циклический сдвиг вправо)
**Описание:** Циклический сдвиг вправо - биты возвращаются с другой стороны

#### Пример 1: Сдвиг на 1 бит
- **Вход:** r0 = 1 (0b0001), shift = 1
- **Ожидаемый результат:** 0x80000000 (2147483648), C = 1
- **Объяснение:** ROR на 1 бит перемещает младший бит в старшую позицию. 1 >>> 1 | 1 << 31 = 0x80000000

#### Пример 2: Сдвиг на 4 бита (8-битное представление)
- **Вход:** r0 = 0x12345678, shift = 4
- **Ожидаемый результат:** 0x81234567, C = 1
- **Объяснение:** ROR на 4 бита циклически сдвигает все биты вправо

#### Пример 3: Сдвиг на 32 (полный оборот)
- **Вход:** r0 = 42, shift = 32
- **Ожидаемый результат:** 42, C = зависит от бита
- **Объяснение:** ROR на 32 бита возвращает число в исходное состояние (32 % 32 = 0)

#### Пример 4: Сдвиг на 33 (эквивалентно 1)
- **Вход:** r0 = 1, shift = 33
- **Ожидаемый результат:** 0x80000000, C = 1
- **Объяснение:** ROR маскирует shift до 5 бит, поэтому 33 % 32 = 1, работает как сдвиг на 1

---

## Арифметические операции

### ADD (сложение)
**Описание:** r2 = r0 + r1

#### Пример 1: Базовое сложение
- **Вход:** r0 = 5, r1 = 7
- **Ожидаемый результат:** 12, N=0, Z=0, C=0, V=0
- **Объяснение:** Простое сложение без переполнения и переноса

#### Пример 2: Сложение с переносом
- **Вход:** r0 = 0xFFFFFFFF (-1), r1 = 1
- **Ожидаемый результат:** 0, N=0, Z=1, C=1, V=0
- **Объяснение:** Сложение -1 и 1 дает 0 с переносом (C=1) и нулевым результатом (Z=1)

#### Пример 3: Переполнение (overflow)
- **Вход:** r0 = 0x7FFFFFFF (2147483647), r1 = 1
- **Ожидаемый результат:** 0x80000000 (-2147483648), N=1, Z=0, C=0, V=1
- **Объяснение:** Сложение максимального положительного числа с 1 вызывает переполнение (V=1), результат становится отрицательным

#### Пример 4: Сложение отрицательных чисел
- **Вход:** r0 = -5, r1 = -3
- **Ожидаемый результат:** -8, N=1, Z=0, C=1, V=0
- **Объяснение:** Сложение двух отрицательных чисел дает отрицательный результат с переносом

---

### SUB (вычитание)
**Описание:** r2 = r0 - r1

#### Пример 1: Базовое вычитание
- **Вход:** r0 = 10, r1 = 3
- **Ожидаемый результат:** 7, N=0, Z=0, C=1, V=0
- **Объяснение:** Вычитание без займа. C=1 означает, что займа не было

#### Пример 2: Вычитание с займом
- **Вход:** r0 = 3, r1 = 10
- **Ожидаемый результат:** -7 (0xFFFFFFF9), N=1, Z=0, C=0, V=0
- **Ожидаемый результат:** C=0 означает, что был займ

#### Пример 3: Вычитание равных чисел
- **Вход:** r0 = 42, r1 = 42
- **Ожидаемый результат:** 0, N=0, Z=1, C=1, V=0
- **Объяснение:** Вычитание равных чисел дает 0 (Z=1) без займа (C=1)

#### Пример 4: Переполнение при вычитании
- **Вход:** r0 = 0x80000000 (-2147483648), r1 = 1
- **Ожидаемый результат:** 0x7FFFFFFF (2147483647), N=0, Z=0, C=1, V=1
- **Объяснение:** Вычитание из минимального отрицательного числа вызывает переполнение (V=1)

---

### RSB (Reverse Subtract, обратное вычитание)
**Описание:** r2 = r1 - r0

#### Пример 1: Базовое обратное вычитание
- **Вход:** r0 = 3, r1 = 10
- **Ожидаемый результат:** 7, N=0, Z=0, C=1, V=0
- **Объяснение:** RSB вычисляет r1 - r0 вместо r0 - r1. 10 - 3 = 7

#### Пример 2: Обратное вычитание с займом
- **Вход:** r0 = 10, r1 = 3
- **Ожидаемый результат:** -7 (0xFFFFFFF9), N=1, Z=0, C=0, V=0
- **Объяснение:** RSB вычисляет 3 - 10 = -7 с займом (C=0)

#### Пример 3: Обратное вычитание равных чисел
- **Вход:** r0 = 42, r1 = 42
- **Ожидаемый результат:** 0, N=0, Z=1, C=1, V=0
- **Объяснение:** 42 - 42 = 0, результат нулевой (Z=1)

---

### MUL (умножение)
**Описание:** r2 = r0 × r1 (младшие 32 бита результата)

#### Пример 1: Базовое умножение
- **Вход:** r0 = 5, r1 = 7
- **Ожидаемый результат:** 35, N=0, Z=0, V=0
- **Объяснение:** Простое умножение без переполнения

#### Пример 2: Умножение на ноль
- **Вход:** r0 = 42, r1 = 0
- **Ожидаемый результат:** 0, N=0, Z=1, V=0
- **Объяснение:** Умножение на ноль дает ноль (Z=1)

#### Пример 3: Умножение отрицательных чисел
- **Вход:** r0 = -5, r1 = 7
- **Ожидаемый результат:** -35, N=1, Z=0, V=0
- **Объяснение:** Умножение отрицательного на положительное дает отрицательный результат

#### Пример 4: Переполнение при умножении
- **Вход:** r0 = 0x10000 (65536), r1 = 0x10000 (65536)
- **Ожидаемый результат:** 0 (младшие 32 бита), N=0, Z=1, V=1
- **Объяснение:** Произведение 65536 × 65536 = 4294967296, что больше 32-битного максимума, V=1 указывает на переполнение

---

### ADC (Add with Carry, сложение с переносом)
**Описание:** r2 = r0 + r1 + C

#### Пример 1: Сложение без переноса
- **Вход:** r0 = 5, r1 = 7, C = 0
- **Ожидаемый результат:** 12, N=0, Z=0, C=0, V=0
- **Объяснение:** ADC с C=0 работает как обычное ADD

#### Пример 2: Сложение с переносом
- **Вход:** r0 = 5, r1 = 7, C = 1
- **Ожидаемый результат:** 13, N=0, Z=0, C=0, V=0
- **Объяснение:** ADC добавляет флаг переноса: 5 + 7 + 1 = 13

#### Пример 3: Многоразрядное сложение (младшие разряды)
- **Вход:** r0 = 0xFFFFFFFF, r1 = 0, C = 1
- **Ожидаемый результат:** 0, N=0, Z=1, C=1, V=0
- **Объяснение:** ADC используется для многоразрядной арифметики. -1 + 0 + 1 = 0 с переносом

#### Пример 4: Переполнение с переносом
- **Вход:** r0 = 0x7FFFFFFF, r1 = 0, C = 1
- **Ожидаемый результат:** 0x80000000, N=1, Z=0, C=0, V=1
- **Объяснение:** Сложение максимального числа с переносом вызывает переполнение

---

### SBC (Subtract with Carry, вычитание с займом)
**Описание:** r2 = r0 - r1 - !C (вычитание с займом)

#### Пример 1: Вычитание без займа
- **Вход:** r0 = 10, r1 = 3, C = 1
- **Ожидаемый результат:** 7, N=0, Z=0, C=1, V=0
- **Объяснение:** SBC с C=1 означает нет займа, поэтому 10 - 3 - 0 = 7

#### Пример 2: Вычитание с займом
- **Вход:** r0 = 10, r1 = 3, C = 0
- **Ожидаемый результат:** 6, N=0, Z=0, C=1, V=0
- **Объяснение:** SBC с C=0 означает есть займ, поэтому 10 - 3 - 1 = 6

#### Пример 3: Многоразрядное вычитание
- **Вход:** r0 = 0, r1 = 0, C = 0
- **Ожидаемый результат:** -1 (0xFFFFFFFF), N=1, Z=0, C=0, V=0
- **Объяснение:** SBC используется для многоразрядной арифметики. 0 - 0 - 1 = -1 с займом

#### Пример 4: Вычитание с переполнением
- **Вход:** r0 = 0x80000000, r1 = 1, C = 1
- **Ожидаемый результат:** 0x7FFFFFFF, N=0, Z=0, C=1, V=1
- **Объяснение:** Вычитание из минимального отрицательного числа вызывает переполнение

---

### RSC (Reverse Subtract with Carry, обратное вычитание с займом)
**Описание:** r2 = r1 - r0 - !C

#### Пример 1: Обратное вычитание без займа
- **Вход:** r0 = 3, r1 = 10, C = 1
- **Ожидаемый результат:** 7, N=0, Z=0, C=1, V=0
- **Объяснение:** RSC с C=1: 10 - 3 - 0 = 7

#### Пример 2: Обратное вычитание с займом
- **Вход:** r0 = 3, r1 = 10, C = 0
- **Ожидаемый результат:** 6, N=0, Z=0, C=1, V=0
- **Объяснение:** RSC с C=0: 10 - 3 - 1 = 6

#### Пример 3: Многоразрядное обратное вычитание
- **Вход:** r0 = 0, r1 = 0, C = 0
- **Ожидаемый результат:** -1 (0xFFFFFFFF), N=1, Z=0, C=0, V=0
- **Объяснение:** RSC для многоразрядной арифметики: 0 - 0 - 1 = -1

---

### CMP (Compare, сравнение)
**Описание:** Устанавливает флаги как SUB, но результат не сохраняется

#### Пример 1: Сравнение равных чисел
- **Вход:** r0 = 42, r1 = 42
- **Ожидаемый результат:** 0 (не сохраняется), N=0, Z=1, C=1, V=0
- **Объяснение:** CMP устанавливает Z=1 для равных чисел, C=1 означает нет займа

#### Пример 2: Сравнение r0 > r1
- **Вход:** r0 = 10, r1 = 3
- **Ожидаемый результат:** 7 (не сохраняется), N=0, Z=0, C=1, V=0
- **Объяснение:** CMP устанавливает C=1 и Z=0, что означает r0 >= r1

#### Пример 3: Сравнение r0 < r1
- **Вход:** r0 = 3, r1 = 10
- **Ожидаемый результат:** -7 (не сохраняется), N=1, Z=0, C=0, V=0
- **Объяснение:** CMP устанавливает C=0 и N=1, что означает r0 < r1

#### Пример 4: Сравнение с переполнением
- **Вход:** r0 = 0x80000000, r1 = 1
- **Ожидаемый результат:** 0x7FFFFFFF (не сохраняется), N=0, Z=0, C=1, V=1
- **Объяснение:** CMP может вызвать переполнение, V=1 указывает на это

---

## Граничные случаи и особые ситуации

### Тест на переполнение 32-битных чисел
- **Операция:** ADD
- **Вход:** r0 = 0x7FFFFFFF (2147483647), r1 = 0x7FFFFFFF
- **Ожидаемый результат:** 0xFFFFFFFE (-2), N=1, Z=0, C=1, V=1
- **Объяснение:** Сложение двух максимальных положительных чисел вызывает переполнение (V=1)

### Тест на работу с нулем
- **Операция:** AND
- **Вход:** r0 = 255, r1 = 0
- **Ожидаемый результат:** 0, N=0, Z=1
- **Объяснение:** AND с нулем всегда дает ноль

### Тест на максимальный сдвиг
- **Операция:** LSL
- **Вход:** r0 = 1, shift = 31
- **Ожидаемый результат:** 0x80000000 (-2147483648), C = 0
- **Объяснение:** Сдвиг на 31 бит перемещает единственный бит в старшую позицию

### Тест на сдвиг на 0
- **Операция:** LSR
- **Вход:** r0 = 42, shift = 0
- **Ожидаемый результат:** 42, C = текущий C
- **Объяснение:** Сдвиг на 0 не изменяет значение

### Тест на отрицательные числа в логических операциях
- **Операция:** EOR
- **Вход:** r0 = -1 (0xFFFFFFFF), r1 = -1
- **Ожидаемый результат:** 0, N=0, Z=1
- **Объяснение:** XOR одинаковых значений (даже отрицательных) дает 0

