# Инструкция по тестированию битового калькулятора

Эта инструкция содержит тестовые примеры для проверки всех операций калькулятора. Каждый пример показывает ввод в **десятичной** и **двоичной** системах счисления.

---

## Логические операции

### AND (побитовое И)
**Описание:** Результат 1 только если оба бита равны 1

#### Пример 1: Базовый случай
- **Десятичный ввод:** r0 = `5`, r1 = `7`
- **Двоичный ввод:** r0 = `101`, r1 = `111`
- **Ожидаемый результат:** `5` (десятичное) или `101` (двоичное)
- **Объяснение:** AND возвращает 1 только там, где оба операнда имеют 1. 5 & 7 = 0b0101 & 0b0111 = 0b0101 = 5

#### Пример 2: Очистка битов
- **Десятичный ввод:** r0 = `255`, r1 = `240`
- **Двоичный ввод:** r0 = `11111111`, r1 = `11110000`
- **Ожидаемый результат:** `240` (десятичное) или `11110000` (двоичное)
- **Объяснение:** Маска 240 очищает младшие 4 бита, оставляя только старшие 4 бита

#### Пример 3: Нулевой результат
- **Десятичный ввод:** r0 = `170`, r1 = `85`
- **Двоичный ввод:** r0 = `10101010`, r1 = `1010101`
- **Ожидаемый результат:** `0` (десятичное) или `0` (двоичное)
- **Объяснение:** Операция AND между взаимно инвертированными битами всегда дает 0

---

### ORR (побитовое ИЛИ)
**Описание:** Результат 1 если хотя бы один бит равен 1

#### Пример 1: Базовый случай
- **Десятичный ввод:** r0 = `5`, r1 = `7`
- **Двоичный ввод:** r0 = `101`, r1 = `111`
- **Ожидаемый результат:** `7` (десятичное) или `111` (двоичное)
- **Объяснение:** OR возвращает 1 если хотя бы один операнд имеет 1. 5 | 7 = 0b0101 | 0b0111 = 0b0111 = 7

#### Пример 2: Установка битов
- **Десятичный ввод:** r0 = `170`, r1 = `85`
- **Двоичный ввод:** r0 = `10101010`, r1 = `1010101`
- **Ожидаемый результат:** `255` (десятичное) или `11111111` (двоичное)
- **Объяснение:** OR между взаимно инвертированными битами устанавливает все биты в 1

#### Пример 3: С нулем
- **Десятичный ввод:** r0 = `42`, r1 = `0`
- **Двоичный ввод:** r0 = `101010`, r1 = `0`
- **Ожидаемый результат:** `42` (десятичное) или `101010` (двоичное)
- **Объяснение:** OR с нулем не изменяет значение операнда

---

### EOR (исключающее ИЛИ, XOR)
**Описание:** Результат 1 если биты различны

#### Пример 1: Базовый случай
- **Десятичный ввод:** r0 = `5`, r1 = `7`
- **Двоичный ввод:** r0 = `101`, r1 = `111`
- **Ожидаемый результат:** `2` (десятичное) или `10` (двоичное)
- **Объяснение:** XOR возвращает 1 только там, где биты различны. 5 ^ 7 = 0b0101 ^ 0b0111 = 0b0010 = 2

#### Пример 2: Инверсия через XOR
- **Десятичный ввод:** r0 = `42`, r1 = `255`
- **Двоичный ввод:** r0 = `101010`, r1 = `11111111`
- **Ожидаемый результат:** `213` (десятичное) или `11010101` (двоичное)
- **Объяснение:** XOR с маской из всех единиц инвертирует все биты

#### Пример 3: С одинаковыми значениями
- **Десятичный ввод:** r0 = `15`, r1 = `15`
- **Двоичный ввод:** r0 = `1111`, r1 = `1111`
- **Ожидаемый результат:** `0` (десятичное) или `0` (двоичное)
- **Объяснение:** XOR одинаковых значений всегда дает 0

---

### BIC (Bit Clear, очистка битов)
**Описание:** A AND NOT B - очищает биты в A, которые установлены в B

#### Пример 1: Базовый случай
- **Десятичный ввод:** r0 = `255`, r1 = `15`
- **Двоичный ввод:** r0 = `11111111`, r1 = `1111`
- **Ожидаемый результат:** `240` (десятичное) или `11110000` (двоичное)
- **Объяснение:** BIC очищает младшие 4 бита, оставляя старшие 4 бита установленными

#### Пример 2: Очистка конкретных битов
- **Десятичный ввод:** r0 = `170`, r1 = `85`
- **Двоичный ввод:** r0 = `10101010`, r1 = `1010101`
- **Ожидаемый результат:** `170` (десятичное) или `10101010` (двоичное)
- **Объяснение:** BIC очищает только те биты в r0, которые установлены в r1. Здесь биты не пересекаются, поэтому результат равен r0

---

### MVN (Move Not, инверсия)
**Описание:** NOT A - инвертирует все биты (унарная операция, r1 игнорируется)

#### Пример 1: Базовый случай
- **Десятичный ввод:** r0 = `5`, r1 = любое (игнорируется)
- **Двоичный ввод:** r0 = `101`, r1 = любое (игнорируется)
- **Ожидаемый результат:** `-6` (десятичное) или `11111111111111111111111111111010` (32-битное двоичное)
- **Объяснение:** MVN инвертирует все биты: ~5 = ~0b0101 = 0b1111...1010 = -6 в знаковом представлении

#### Пример 2: Инверсия нуля
- **Десятичный ввод:** r0 = `0`, r1 = любое (игнорируется)
- **Двоичный ввод:** r0 = `0`, r1 = любое (игнорируется)
- **Ожидаемый результат:** `-1` (десятичное) или `11111111111111111111111111111111` (32-битное двоичное)
- **Объяснение:** Инверсия нуля дает все единицы, что в знаковом представлении равно -1

---

## Операции сдвига

### LSL (Logical Shift Left, логический сдвиг влево)
**Описание:** Сдвиг влево, справа входят нули. Эквивалентно умножению на 2^n

#### Пример 1: Сдвиг на 1 бит
- **Десятичный ввод:** r0 = `5`, shift = `1`
- **Двоичный ввод:** r0 = `101`, shift = `1`
- **Ожидаемый результат:** `10` (десятичное) или `1010` (двоичное), C = 0
- **Объяснение:** LSL на 1 бит умножает на 2. 5 << 1 = 10. Флаг C = старший выдвинутый бит

#### Пример 2: Сдвиг на 2 бита
- **Десятичный ввод:** r0 = `3`, shift = `2`
- **Двоичный ввод:** r0 = `11`, shift = `2`
- **Ожидаемый результат:** `12` (десятичное) или `1100` (двоичное), C = 0
- **Объяснение:** LSL на 2 бита умножает на 4. 3 << 2 = 12

#### Пример 3: Сдвиг на 0
- **Десятичный ввод:** r0 = `42`, shift = `0`
- **Двоичный ввод:** r0 = `101010`, shift = `0`
- **Ожидаемый результат:** `42` (десятичное) или `101010` (двоичное), C = текущий C
- **Объяснение:** Сдвиг на 0 не изменяет значение, флаг C сохраняется

---

### LSR (Logical Shift Right, логический сдвиг вправо)
**Описание:** Сдвиг вправо, слева входят нули. Эквивалентно беззнаковому делению на 2^n

#### Пример 1: Сдвиг на 1 бит
- **Десятичный ввод:** r0 = `10`, shift = `1`
- **Двоичный ввод:** r0 = `1010`, shift = `1`
- **Ожидаемый результат:** `5` (десятичное) или `101` (двоичное), C = 0
- **Объяснение:** LSR на 1 бит делит на 2. 10 >>> 1 = 5. Флаг C = младший выдвинутый бит

#### Пример 2: Сдвиг на 2 бита
- **Десятичный ввод:** r0 = `12`, shift = `2`
- **Двоичный ввод:** r0 = `1100`, shift = `2`
- **Ожидаемый результат:** `3` (десятичное) или `11` (двоичное), C = 0
- **Объяснение:** LSR на 2 бита делит на 4. 12 >>> 2 = 3

#### Пример 3: Сдвиг с переносом
- **Десятичный ввод:** r0 = `1`, shift = `1`
- **Двоичный ввод:** r0 = `1`, shift = `1`
- **Ожидаемый результат:** `0` (десятичное) или `0` (двоичное), C = 1
- **Объяснение:** Сдвиг числа 1 выдвигает 1 в флаг C, результат становится 0

---

### ASR (Arithmetic Shift Right, арифметический сдвиг вправо)
**Описание:** Сдвиг вправо с сохранением знака. Слева копируется бит знака

#### Пример 1: Сдвиг положительного числа
- **Десятичный ввод:** r0 = `10`, shift = `1`
- **Двоичный ввод:** r0 = `1010`, shift = `1`
- **Ожидаемый результат:** `5` (десятичное) или `101` (двоичное), C = 0
- **Объяснение:** ASR положительного числа работает как LSR. 10 >> 1 = 5

#### Пример 2: Сдвиг отрицательного числа
- **Десятичный ввод:** r0 = `-10`, shift = `1`
- **Двоичный ввод:** r0 = `11111111111111111111111111110110` (32-битное представление -10), shift = `1`
- **Ожидаемый результат:** `-5` (десятичное), C = 0
- **Объяснение:** ASR сохраняет знак, поэтому -10 >> 1 = -5. Старший бит (знак) копируется

#### Пример 3: Сдвиг на 2 бита отрицательного числа
- **Десятичный ввод:** r0 = `-8`, shift = `2`
- **Двоичный ввод:** r0 = `11111111111111111111111111111000` (32-битное представление -8), shift = `2`
- **Ожидаемый результат:** `-2` (десятичное), C = 0
- **Объяснение:** ASR делит с сохранением знака. -8 >> 2 = -2

---

### ROR (Rotate Right, циклический сдвиг вправо)
**Описание:** Циклический сдвиг вправо - биты возвращаются с другой стороны

#### Пример 1: Сдвиг на 1 бит
- **Десятичный ввод:** r0 = `1`, shift = `1`
- **Двоичный ввод:** r0 = `1`, shift = `1`
- **Ожидаемый результат:** `2147483648` (десятичное) или `10000000000000000000000000000000` (32-битное), C = 1
- **Объяснение:** ROR на 1 бит перемещает младший бит в старшую позицию. 1 >>> 1 | 1 << 31 = 0x80000000

#### Пример 2: Сдвиг на 4 бита
- **Десятичный ввод:** r0 = `305419896` (0x12345678), shift = `4`
- **Двоичный ввод:** r0 = `10010001101000101011001111000` (32-битное), shift = `4`
- **Ожидаемый результат:** `2164261223` (десятичное), C = 1
- **Объяснение:** ROR на 4 бита циклически сдвигает все биты вправо

---

## Арифметические операции

### ADD (сложение)
**Описание:** r2 = r0 + r1

#### Пример 1: Базовое сложение
- **Десятичный ввод:** r0 = `5`, r1 = `7`
- **Двоичный ввод:** r0 = `101`, r1 = `111`
- **Ожидаемый результат:** `12` (десятичное) или `1100` (двоичное), N=0, Z=0
- **Объяснение:** Простое сложение без переполнения и переноса

#### Пример 2: Сложение с переносом
- **Десятичный ввод:** r0 = `-1`, r1 = `1`
- **Двоичный ввод:** r0 = `11111111111111111111111111111111` (32-битное), r1 = `1`
- **Ожидаемый результат:** `0` (десятичное) или `0` (двоичное), N=0, Z=1
- **Объяснение:** Сложение -1 и 1 дает 0 с нулевым результатом (Z=1)

#### Пример 3: Переполнение (overflow)
- **Десятичный ввод:** r0 = `2147483647`, r1 = `1`
- **Двоичный ввод:** r0 = `1111111111111111111111111111111` (31 единица), r1 = `1`
- **Ожидаемый результат:** `-2147483648` (десятичное), N=1, Z=0
- **Объяснение:** Сложение максимального положительного числа с 1 вызывает переполнение, результат становится отрицательным

---

### SUB (вычитание)
**Описание:** r2 = r0 - r1

#### Пример 1: Базовое вычитание
- **Десятичный ввод:** r0 = `10`, r1 = `3`
- **Двоичный ввод:** r0 = `1010`, r1 = `11`
- **Ожидаемый результат:** `7` (десятичное) или `111` (двоичное), N=0, Z=0
- **Объяснение:** Вычитание без займа

#### Пример 2: Вычитание с займом
- **Десятичный ввод:** r0 = `3`, r1 = `10`
- **Двоичный ввод:** r0 = `11`, r1 = `1010`
- **Ожидаемый результат:** `-7` (десятичное), N=1, Z=0
- **Объяснение:** Вычитание большего числа из меньшего дает отрицательный результат

#### Пример 3: Вычитание равных чисел
- **Десятичный ввод:** r0 = `42`, r1 = `42`
- **Двоичный ввод:** r0 = `101010`, r1 = `101010`
- **Ожидаемый результат:** `0` (десятичное) или `0` (двоичное), N=0, Z=1
- **Объяснение:** Вычитание равных чисел дает 0 (Z=1)

---

### RSB (Reverse Subtract, обратное вычитание)
**Описание:** r2 = r1 - r0

#### Пример 1: Базовое обратное вычитание
- **Десятичный ввод:** r0 = `3`, r1 = `10`
- **Двоичный ввод:** r0 = `11`, r1 = `1010`
- **Ожидаемый результат:** `7` (десятичное) или `111` (двоичное), N=0, Z=0
- **Объяснение:** RSB вычисляет r1 - r0 вместо r0 - r1. 10 - 3 = 7

#### Пример 2: Обратное вычитание с займом
- **Десятичный ввод:** r0 = `10`, r1 = `3`
- **Двоичный ввод:** r0 = `1010`, r1 = `11`
- **Ожидаемый результат:** `-7` (десятичное), N=1, Z=0
- **Объяснение:** RSB вычисляет 3 - 10 = -7

---

### MUL (умножение)
**Описание:** r2 = r0 × r1 (младшие 32 бита результата)

#### Пример 1: Базовое умножение
- **Десятичный ввод:** r0 = `5`, r1 = `7`
- **Двоичный ввод:** r0 = `101`, r1 = `111`
- **Ожидаемый результат:** `35` (десятичное) или `100011` (двоичное), N=0, Z=0
- **Объяснение:** Простое умножение без переполнения

#### Пример 2: Умножение на ноль
- **Десятичный ввод:** r0 = `42`, r1 = `0`
- **Двоичный ввод:** r0 = `101010`, r1 = `0`
- **Ожидаемый результат:** `0` (десятичное) или `0` (двоичное), N=0, Z=1
- **Объяснение:** Умножение на ноль дает ноль (Z=1)

#### Пример 3: Умножение отрицательных чисел
- **Десятичный ввод:** r0 = `-5`, r1 = `7`
- **Двоичный ввод:** r0 = `11111111111111111111111111111011` (32-битное -5), r1 = `111`
- **Ожидаемый результат:** `-35` (десятичное), N=1, Z=0
- **Объяснение:** Умножение отрицательного на положительное дает отрицательный результат

---

### CMP (Compare, сравнение)
**Описание:** Устанавливает флаги как SUB, но результат не сохраняется

#### Пример 1: Сравнение равных чисел
- **Десятичный ввод:** r0 = `42`, r1 = `42`
- **Двоичный ввод:** r0 = `101010`, r1 = `101010`
- **Ожидаемый результат:** `0` (не сохраняется), N=0, Z=1
- **Объяснение:** CMP устанавливает Z=1 для равных чисел

#### Пример 2: Сравнение r0 > r1
- **Десятичный ввод:** r0 = `10`, r1 = `3`
- **Двоичный ввод:** r0 = `1010`, r1 = `11`
- **Ожидаемый результат:** `7` (не сохраняется), N=0, Z=0
- **Объяснение:** CMP устанавливает Z=0 и N=0, что означает r0 > r1

#### Пример 3: Сравнение r0 < r1
- **Десятичный ввод:** r0 = `3`, r1 = `10`
- **Двоичный ввод:** r0 = `11`, r1 = `1010`
- **Ожидаемый результат:** `-7` (не сохраняется), N=1, Z=0
- **Объяснение:** CMP устанавливает N=1 и Z=0, что означает r0 < r1

---

## Граничные случаи

### Тест на переполнение 32-битных чисел
- **Операция:** ADD
- **Десятичный ввод:** r0 = `2147483647`, r1 = `2147483647`
- **Двоичный ввод:** r0 = `1111111111111111111111111111111` (31 единица), r1 = `1111111111111111111111111111111`
- **Ожидаемый результат:** `-2` (десятичное), N=1, Z=0
- **Объяснение:** Сложение двух максимальных положительных чисел вызывает переполнение

### Тест на работу с нулем
- **Операция:** AND
- **Десятичный ввод:** r0 = `255`, r1 = `0`
- **Двоичный ввод:** r0 = `11111111`, r1 = `0`
- **Ожидаемый результат:** `0` (десятичное) или `0` (двоичное), N=0, Z=1
- **Объяснение:** AND с нулем всегда дает ноль

### Тест на максимальный сдвиг
- **Операция:** LSL
- **Десятичный ввод:** r0 = `1`, shift = `31`
- **Двоичный ввод:** r0 = `1`, shift = `31`
- **Ожидаемый результат:** `-2147483648` (десятичное), C = 0
- **Объяснение:** Сдвиг на 31 бит перемещает единственный бит в старшую позицию

### Тест на сдвиг на 0
- **Операция:** LSR
- **Десятичный ввод:** r0 = `42`, shift = `0`
- **Двоичный ввод:** r0 = `101010`, shift = `0`
- **Ожидаемый результат:** `42` (десятичное) или `101010` (двоичное), C = текущий C
- **Объяснение:** Сдвиг на 0 не изменяет значение

---

## Как использовать эту инструкцию

1. **Выберите операцию** из списка выше
2. **Выберите пример** для тестирования
3. **Введите значения** в калькулятор:
   - Переключитесь на "Десятичный ввод" и введите значения из раздела "Десятичный ввод"
   - Или переключитесь на "Двоичный ввод" и введите значения из раздела "Двоичный ввод"
4. **Выполните операцию** нажав соответствующую кнопку
5. **Проверьте результат** - он должен совпадать с ожидаемым результатом
6. **Проверьте флаги** N и Z - они должны совпадать с указанными в примере

---

## Примечания

- Все числа в примерах представлены как 32-битные знаковые целые
- Отрицательные числа в двоичном представлении показаны в 32-битном формате
- Флаги N (Negative) и Z (Zero) отображаются после каждой операции
- Для операций сдвига значение shift ограничено диапазоном 0-31

